---
title: '[MySQL] Index'
date: '2020-08-11T16:09:32.169Z'
template: 'post'
draft: false
slug: 'mysql-index'
category: 'mysql'
tags:
  - 'database'
  - 'mysql'
  - 'index'
description: 'Index란?'
socialImage: 'https://i.kym-cdn.com/entries/icons/facebook/000/019/513/til.jpg'
---

# Index

인덱스는 데이터베이스 쿼리 성능을 언급하면서 뺴놓을 수 없는 부분이다.

이 글에서는 MySQL에서 사용 가능한 인덱스의 종류 및 특성을 알아볼 것이다.

인덱스를 알아보기 전에 랜덤I/O와 순차I/O같은 디스크 읽기 방식부터 간단히 보고 넘어가자

## 디스크 읽기 방식

데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다.

먼저 데이터를 저장할 수 있는 매체에 대해 살펴보자.

### 저장 매체

내장 디스크(Internal Disk)

- 개인 PC의 본체 내에 장착된 디스크와 같은 매체
- 4~6개 정도의 내장 디스크를 장착한다.
- 컴퓨터 내부의 공간이 제한적이어서 디스크의 개수가 적고 용량이 부족하다.

DAS(Direct Attached Storage)

- 내장디스크의 용량문제를 해결하기 위해 주로 사용
- 컴퓨터 본체와 달리 디스크만 있는 것이 특징이며, 독자적으로 사용할 수 없고 컴퓨터 본체에 연결해서만 사용할 수 있다.
- 반드시 하나의 컴퓨터 본체에만 연결해서 사용할 수 있기 때문에 디스크 정보를 여러 컴퓨터가 동시에 공유하는 것이 불가능하다.

NAS(Network Attached Storage)

- 여러 컴퓨터에서 동시 사용 가능
- NAS는 TCP/IP로 데이터가 전송되기 때문에 데이터의 읽고 쓰기가 빈번한 데이터베이스에서는 거의 사용되지 않는다.

SAN(Storage Area Network)

- DAS로 구축할 수 없는 대용량 스토리지 공간을 제공하는 장치
- 여러 컴퓨터에 동시에 사용할 수 있고 광케이블로 연결되기 떄문에 빠르고 안정적인 읽고쓰기를 보장해 준다.
- 고가의 비용이 들기 때문에 중요 데이터를 보관할 경우에만 일반적으로 사용한다.

#### 성능 순서

내장 디스크 → DAS → SAN

## 디스크 드라이브와 솔리드 스테이트 드라이브

CPU나 메모리같은 주요 장치는 대부분 전자식 장치지만 디스크 드라이브는 기계식 장치다.

데이터베이스 서버에서는 항상 디스크 장치가 병목 지점이기 때문에 전자식 저장 매체인 SSD가 많이 출시되고 있다.

SSD는 기존 디스크 드라이브에서 데이터 저장용 플래터를 제거하고 플래시 메모리를 장착하고 있다.

### 성능

디스크 헤더를 움직이지 않는 순차 IO 작업에서는 SSD가 디스크 드라이브보다 조금 빠르거나 거의 비슷한 수준이지만 랜덤 IO에서는 SSD가 훨씬 빠르다.

### **랜덤 I/O vs 순차 I/O**

일단 I/O란 입출력 (input & output)의 준말이 되겠다.

랜덤 I/O는 **디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽어들이는 것**을 의미하는데 실상 순차 I/O도 하는 작업은 동일하다.

성능

- 디스크에 데이터를 읽고 쓰는데 걸리는 시간은 **디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계**에서 결정된다.
- 디스크의 성능은 **디스크 헤더의 위치이동 없이 얼마나 많은 데이터를 한번에 기록하느냐**에 의해 결정된다.
- 랜덤 I/O는 순차 I/O에 비해 **여러번** 쓰기 또는 읽기 **요청**을 한다. (즉, 작업 부하가 커진다.)

사용

- 쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸어 실행할 방법은 많지 않다.
- 쿼리 튜닝은 랜덤 I/O 자체를 줄이는 것이 목적이다.
- 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용
- 풀테이블 스캔은 주로 순차 I/O를 사용
- 위 두가지 이유로, 주로 **Data Warehouse**나 **DB Table 통계작업** 등에는 테이블이 큰 경우 인덱스 레인지 스캔보다 풀 테이블 스캔을 유도하는 경우도 있음.

## 인덱스란?

- 테이블의 검색 속도를 높여주는 기능

- 책의 제일 끝에 있는 색인과 같은 개념

- 뒤에 있는 책의 찾아보기가 **인덱스**라면 책의 내용은 **데이터 파일**이고 페이지 번호는 데이터 파일에 저장된 **레코드 주소**다.

- 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸린다.

  그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키값 쌍으로 인덱스를 만들어두는 것이다.

  책의 색인이 많아지면 원하는 내용을 찾기가 힘들어지기 때문에 ㄱ,ㄴ,ㄷ 순서로 정렬되어 있는데, 데이터베이스도 마찬가지로 칼럼의 값을 미리 정렬해서 보관한다.

- 인덱스가 많은 테이블은 INSERT, UPDATE, DELETE 문장의 처리가 느려지고 SELECT 문장은매우 빠르게 처리된다.

- 여기서 알 수 있듯 테이블의 인덱스를 하나 더 추가할지 말지는 데이터 저장속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 빠르게 만들어야하는지 여부에 다라 결정되어야 한다.

데이터 저장방식별 구분

- B-Tree
  - 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash
  - 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘
- Fractal-Tree
  - B-Tree와 거의 비슷하지만 B-Tree의 단점인 데이터가 저장되거나 삭제될 때 발생하는 처리 비용을 상당히 줄일 수 있게 된 알고리즘

데이터 중복 허용 여부 분류

- 유니크 인덱스
- Non-유니크 인덱스

유니크 인덱스에 대해 동등조건으로 검색하는건 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과가 있다.

** 유니크와 PK

## B-Tree 인덱스

데이터베이스 인덱싱 알고리즘중에 가장 일반적으로 사용되고 가장 먼저 도입된 알고리즘

B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지하고 있다.

### 구조 및 특성

- 루트 노드 하위에 자식 노드가 붙어있는 형태

- 가장 하위 노드를 리프노드라고 하고 루트노드와 리프노드 중간에 있는 노드를 브랜치 노드라고 한다.

- 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.

- 인덱스의 키값은 모두 정렬돼 있지만 데이터파일의 레코드는 정렬돼있지 않고 임의의 순서대로 저장되어 있다. 데이터가 중간에 삭제되어 빈공간이 생기면 그 다음 INSERT는 삭제된 공간을 재활용하도록 설계되어있기 때문이다.

- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.

  ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aeb84246-b744-4bb3-bb4e-13e77844529e/_2020-08-07__2.09.14.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aeb84246-b744-4bb3-bb4e-13e77844529e/_2020-08-07__2.09.14.png)

## B-Tree 인덱스 키 추가 및 삭제

테이블의 레코드를 저장하거나 변경하는 경우, 인덱스 키 추가나 삭제 작업이 발생한다.

### 인덱스 키 추가

새로운 키값을 저장할 위치가 결정되면 리프노드에 레코드의 키값과 대상 레코드의 주소 정보를 저장한다.

리프노드가 꽉차서 더 저장할 수 없을 때는 리프노드가 분리되어야 하는데 이는 상위 브랜치 노드까지 처리 범위가 넓어진다.

이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려졌다.

테이블에 레코드를 추가하는 작업 비용을 1이라고 한다면 인덱스에 키를 추가하는 작업 비용은 1~1.5정도로 예측하는 것이 일반적이다.

인서트 버퍼 처리

MyISAM 엔진을 사용하는 테이블에서는 INSERT문장이 실행되면 즉시 새로운 키값을 B-TREE 인덱스에 반영하기 때문에 키를 추가하는 작업이 완료될 때 까지 클라이언트는 쿼리의 결과를 받지 못하고 대기한다.

InnoDB는 인덱스 키 추가작업을 지연시켜서 처리할지, 바로처리할 지 결정할 수 있다. (그림 참고)

인덱스 키 삭제

해당 키값이 저장된 B-TREE 리프노드를 찾아서 그냥 삭제하면 작업이 완료된다.

인덱스 키 변경

B-Tree의 키값 변경 작업은 키값을 삭제한 후 새로운 키값을 추가하는 형태로 처리된다.

** 처리 방법 다시 확인

인덱스 키 검색

루트노드 → 브랜치노드 → 리프노드까지 이동하면서 비교작업을 수행한다. (트리 탐색)

인덱스를 이용한 검색은 100%일치 or 값의 앞부분이 일치하는 경우 사용 가능

## B-Tree 인덱스 사용에 영향을 미치는 요소

인덱스를 구성하는 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키값의 개수

### 인덱스 키값의 크기

데이터 저장 기본 단위는 페이지, 블록

InnoDB의 모든 페이지 크기는 16KB 고정이다.

만약 인덱스 키가 16바이트, 자식노드주소크기가 12바이트면 하나의 인덱스 페이지에 585개의 키를 저장할 수 있다. 인덱스 키가 32바이트라면 372개를 저장할 수 있다.

- 만약 SELECT쿼리가 500개를 읽어야 한다면 전자는 한번, 후자는 2번 이상 디스크로부터 읽어야 한다. 결국 디스크로부터 읽어야 하는 횟수가 늘어나서 느려진다는 것을 의미한다.

인덱스의 크기가 커지면 커질수록 메모리에 캐시해둘 수 있는 레코드 수도 줄어드는 것을 의미한다.

### B-Tree 깊이

비트리 깊이가 3인 경우

16바이트인 경우 최대 2억개

32바이트로 늘어나면 5천만개

결론적으로 인덱스 키값의 크기가 커지면 페이지에 담을 수 있는 인덱스 키값의 개수가 적어지고 그때문에 깊이도 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다.

### 선택도(기수성) Selectivity(Cardinality)

모든 인덱스 키값 가운데 유니크한 값의 수

전체 인덱스 키값은 100개 인데, 그중 유니크한 값의 수가 10개라면 기수성은 10이다.

인덱스는 선택도가 높을수록 검색대상이 줄어서 그만큼 빠르게 처리된다.

예제 참고

인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미치게 된다.

### 읽어야 하는 레코드의 건수

테이블에 레코드가 100만건 저장돼 있을 때 50만건을 읽어야 하는 쿼리가 있다고 가정해 보자.

인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

인덱스를 통해 레코드 1건을 읽는게 직접 레코드 1건을 읽는 것 보다 4~5배정도 비용이 많이드는 작업으로 예측한다.

## B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔

인덱스 접근방법 중 가장 대표적인 접근 방식. 나머지 두가지 방식보다 빠르다.

검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

``` SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';```

<img align="left" src="/Users/seungjune/blog/DanSJKim.github.io/static/media/index-range-scan.png" alt="index-range-scan" style="zoom:50%;" />

### 인덱스 풀 스캔

인덱스의 처음부터 끝까지 모두 읽는 방식

<img align="left" src="/Users/seungjune/blog/DanSJKim.github.io/static/media/index-full-scan.png" alt="index-full-scan " style="zoom:50%;" />

### 루스 인덱스 스캔

느슨하게 또는 듬성듬성하게 인덱스를 읽는 방식

중간마다 필요하지 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리한다.

<img align="left" src="/Users/seungjune/Library/Application Support/typora-user-images/스크린샷 2020-08-10 오전 10.19.15.png" alt="스크린샷 2020-08-10 오전 10.19.15" style="zoom:50%;" />

## 다중 칼럼 인덱스

두 개 이상의 칼럼으로 구성된 인덱스

두번째 칼럼은 첫번쨰 칼럼에 의존해서 정렬된다.

<img align="left" src="/Users/seungjune/blog/DanSJKim.github.io/static/media/multi-column-index.png" alt="multi-column-index" style="zoom:50%;" />

## B-Tree 인덱스의 정렬 및 스캔 방향

### 인덱스의 정렬

일반적인 상용 DMBS에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순을 설정할 수 있다. MySQL은 정렬방식을 혼합해서 생성하는 기능은 지원하지 않는다.

### 인덱스 스캔 방향

MySQL에서 인덱스를 역순으로 정렬할 수는 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 효과를 얻을 수 있다.

## B-Tree 인덱스의 가용성과 효율성

WHERE조건, GROUP BY, ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 없는지 살펴본다.

인덱스 칼럼의 순서와 그 칼럼에 사용된 조건이 동등비교인지 범위조건인지에 따라 인덱스 칼럼 활용 형태가 달라진다.